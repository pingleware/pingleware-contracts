// SPDX-License-Identifier: CC-BY-4.0
pragma solidity >=0.4.22 <0.9.0;

import "../common/Owned.sol";
import "../common/Version.sol";
import "./SupplierRole.sol";
import "./ManufacturerRole.sol";
import "./DistributorRole.sol";
import "./ResellerRole.sol";
import "./EndUserRole.sol";

contract SupplyChain is Owned, SupplierRole, ManufacturerRole, DistributorRole, ResellerRole, EndUserRole {
    // Define a variable called 'sku' for Stock Keeping Unit (SKU)
    uint  sku;
    uint  upc;

    // Define a public mapping of the UPC to a Product.
    mapping (uint => Product) products;

    // Define a public mapping 'history' that maps the UPC to an array of TxHash,
    // that track its journey through the supply chain -- to be sent from DApp.
    //mapping (uint => Txblocks[]) history;

    // Define enum 'State' with the following values:
    enum State
    {
        OrderedFromSupplier,        // 0
        ShippedBySupplier,          // 1
        ProduceByManufacturer,      // 2
        ForSaleByManufacturer,      // 3
        PurchasedByDistributor,     // 4
        ShippedByManufacturer,      // 5
        ReceivedByDistributor,      // 6
        ProcessedByDistributor,     // 7
        PackageByDistributor,       // 8
        ForSaleByDistributor,       // 9
        PurchasedByReseller,        // 10
        ShippedByDistributor,       // 11
        ReceivedByReseller,         // 12
        ForSaleByReseller,          // 13
        PurchasedByEndUser          // 14
    }


    State constant defaultState = State.OrderedFromSupplier;

    // Define a struct 'Product' with the following fields:
    struct Product {
        uint    sku;  // Stock Keeping Unit (SKU)
        uint    upc; // Universal Product Code (UPC), generated by the Manufacturer, goes on the package, can be verified by the EndUser
        uint    lot; // Lot number
        uint    manufacturedDate; // The manufacturing date
        address ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        address distributorID;
        address payable originID; // Metamask-Ethereum address of the Manufacturer
        string  originName; // Winemaker Name
        string  originInformation;  // Winemaker Information
        string  originLatitude; // Winemaker Latitude
        string  originLongitude;  // Winemaker Longitude
        uint    productID;  // Product ID potentially a combination of upc + sku
        string  productNotes; // Product Notes
        uint    productPrice; // Product Price
        uint    productFinalPrice; // Final price pof the product when sales by the wine merchant
        uint    productSliced;
        State   productState;  // Product State as represented in the enum above
        address payable resellerID;  // Metamask-Ethereum address of the Wine Merchant
        address payable enduserID; // Metamask-Ethereum address of the EndUser
    }

    // Block number stuct
    struct Txblocks {
        uint STM; // blocksupplierToManufacturer
        uint MTD; // blockmanufacturerToDistributor
        uint DTR; // blockDistributorToReseller
        uint RTC; // blockResellerToEnduser
    }

    event OrderedFromSupplier(uint upc);        //1
    event ShippedBySupplier(uint upc);          //2
    event ProduceByManufacturer(uint upc);      //2
    event ForSaleByManufacturer(uint upc);      //3
    event PurchasedByDistributor(uint upc);     //4
    event ShippedByManufacturer(uint upc);      //5
    event ReceivedByDistributor(uint upc);      //6
    event ProcessedByDistributor(uint upc);     //7
    event PackagedByDistributor(uint upc);      //8
    event ForSaleByDistributor(uint upc);       //9
    event PurchasedByReseller(uint upc);        //10
    event ShippedByDistributor(uint upc);       //11
    event ReceivedByReseller(uint upc);         //12
    event ForSaleByReseller(uint upc);          //13
    event PurchasedByEndUser(uint upc);         //14

  // Define a modifer that verifies the Caller
  modifier verifyCaller (address _address) {
    require(msg.sender == _address, "");
    _;
  }

  // Define a modifier that checks if the paid amount is sufficient to cover the price
  modifier paidEnough(uint _price) {
    require(msg.value >= _price, "");
    _;
  }

  // Define a modifier that checks the price and refunds the remaining balance
  modifier checkValue(uint _upc, address payable addressToFund) {
    uint _price = products[_upc].productPrice;
    uint  amountToReturn = msg.value - _price;
    addressToFund.transfer(amountToReturn);
    _;
  }

//Product State Modifiers
  modifier producedByManufacturer(uint _upc) {
    require(products[_upc].productState == State.ProduceByManufacturer, "");
    _;
  }

  modifier forSaleByManufacturer(uint _upc) {
    require(products[_upc].productState == State.ForSaleByManufacturer, "");
    _;
  }

  modifier purchasedByDistributor(uint _upc) {
    require(products[_upc].productState == State.PurchasedByDistributor, "");
    _;
  }

  modifier shippedByManufacturer(uint _upc) {
    require(products[_upc].productState == State.ShippedByManufacturer, "");
    _;
  }

  modifier receivedByDistributor(uint _upc) {
    require(products[_upc].productState == State.ReceivedByDistributor, "");
    _;
  }

  modifier processByDistributor(uint _upc) {
    require(products[_upc].productState == State.ProcessedByDistributor, "");
    _;
  }

  modifier packagedByDistributor(uint _upc) {
    require(products[_upc].productState == State.PackageByDistributor, "");
    _;
  }

  modifier forSaleByDistributor(uint _upc) {
    require(products[_upc].productState == State.ForSaleByDistributor, "");
    _;
  }


  modifier shippedByDistributor(uint _upc) {
    require(products[_upc].productState == State.ShippedByDistributor, "");
    _;
  }

  modifier purchasedByReseller(uint _upc) {
    require(products[_upc].productState == State.PurchasedByReseller, "");
    _;
  }

  modifier receivedByReseller(uint _upc) {
    require(products[_upc].productState == State.ReceivedByReseller, "");
    _;
  }

  modifier forSaleByReseller(uint _upc) {
    require(products[_upc].productState == State.ForSaleByReseller, "");
    _;
  }

  modifier purchasedByEndUser(uint _upc) {
    require(products[_upc].productState == State.PurchasedByEndUser, "");
    _;
  }

// constructor setup owner sku upc
  constructor() payable {
    sku = 1;
    upc = 1;
  }

    // Define a function 'kill'
  function kill() public {
    if (msg.sender == getOwner()) {
      address payable ownerAddressPayable = _make_payable(getOwner());
      selfdestruct(ownerAddressPayable);
    }
  }


    // allows you to convert an address into a payable address
  function _make_payable(address x) internal pure returns (address payable) {
    return payable(x);
  }

/*
 1st step in supplychain
 Allows manufacturer to create cheese
*/
  function produceProductByManufacturer(
    uint _upc,
    string memory _originName,
    string memory _originInformation,
    string memory _originLatitude,
    string memory _originLongitude,
    string memory _productNotes,
    uint _price,
    uint256 epoch)
        public
        payable
        onlyManufacturer() // check address belongs to manufacturerRole
    {

    address distributorID; // Empty distributorID address
    address resellerID; // Empty resellerID address
    address enduserID; // Empty enduserID address
    Product memory newProduce; // Create a new struct Product in memory
    newProduce.sku = sku;  // Stock Keeping Unit (SKU)
    newProduce.upc = _upc; // Universal Product Code (UPC), generated by the Manufacturer, goes on the package, can be verified by the EndUser
    newProduce.ownerID = msg.sender;  // Metamask-Ethereum address of the current owner as the product moves through 8 stages
    newProduce.originID = payable(msg.sender); // Metamask-Ethereum address of the Manufacturer
    newProduce.originName = _originName;  // Manufacturer Name
    newProduce.originInformation = _originInformation; // Manufacturer Information
    newProduce.originLatitude = _originLatitude; // Farm Latitude
    newProduce.originLongitude = _originLongitude;  // Farm Longitude
    newProduce.productID = _upc+sku;  // Product ID
    newProduce.productNotes = _productNotes; // Product Notes
    newProduce.productPrice = _price;  // Product Price
    newProduce.manufacturedDate = epoch;
    newProduce.productSliced = 0;
    newProduce.productState = defaultState; // Product State as represented in the enum above
    newProduce.distributorID = distributorID; // Metamask-Ethereum address of the Distributor
    newProduce.resellerID = payable(resellerID); // Metamask-Ethereum address of the Reseller
    newProduce.enduserID = payable(enduserID); // Metamask-Ethereum address of the EndUser // ADDED payable
    products[_upc] = newProduce; // Add newProduce to products struct by upc
    //uint placeholder; // Block number place holder
    //Txblocks memory txBlock; // create new txBlock struct
    //txBlock.STM = placeholder;
    //txBlock.MTD = placeholder; // assign placeholder values
    //txBlock.DTR = placeholder;
    //txBlock.RTC = placeholder;
    //history[_upc] = txBlock; // add txBlock to history mapping by upc

    // Increment sku
    sku = sku + 1;

    // Emit the appropriate event
    emit ProduceByManufacturer(_upc);

  }

/*
2nd step in supplychain
Allows manufacturer to sell cheese
*/
  function sellProductByManufacturer(uint _upc, uint _price) public
    onlyManufacturer() // check msg.sender belongs to manufacturerRole
    producedByManufacturer(_upc) // check products state has been produced
    verifyCaller(products[_upc].ownerID) // check msg.sender is owner
    {
      products[_upc].productState = State.ForSaleByManufacturer;
      products[_upc].productPrice = _price;
      emit ForSaleByManufacturer(_upc);
  }

/*
3rd step in supplychain
Allows distributor to purchase cheese
*/
  function purchaseProductByDistributor(uint _upc)
    public
    payable
    onlyDistributor() // check msg.sender belongs to distributorRole
    forSaleByManufacturer(_upc) // check products state is for ForSaleByManufacturer
    paidEnough(products[_upc].productPrice) // check if distributor sent enough Ether for cheese
    checkValue(_upc, payable(msg.sender)) // check if overpayed return remaing funds back to msg.sender
    {
    address payable ownerAddressPayable = _make_payable(products[_upc].originID); // make originFarmID payable
    ownerAddressPayable.transfer(products[_upc].productPrice); // transfer funds from distributor to manufacturer
    products[_upc].ownerID = msg.sender; // update owner
    products[_upc].distributorID = msg.sender; // update distributor
    products[_upc].productState = State.PurchasedByDistributor; // update state
    //history[_upc].STM = block.number; // add block number
    emit PurchasedByDistributor(_upc);

  }

  /*
  4th step in supplychain
  Allows manufacturer to ship cheese purchased by distributor
  */
  function shippedProductByManufacturer(uint _upc) public payable
    onlyManufacturer() // check msg.sender belongs to ManufacturerRole
    purchasedByDistributor(_upc)
    verifyCaller(products[_upc].originID) // check msg.sender is originFarmID
    {
    products[_upc].productState = State.ShippedByManufacturer; // update state
    emit ShippedByManufacturer(_upc);
  }

  /*
  5th step in supplychain
  Allows distributor to receive cheese
  */
  function receivedProductByDistributor(uint _upc) public
    onlyDistributor() // check msg.sender belongs to DistributorRole
    shippedByManufacturer(_upc)
    verifyCaller(products[_upc].ownerID) // check msg.sender is owner
    {
    products[_upc].productState = State.ReceivedByDistributor; // update state
    emit ReceivedByDistributor(_upc);
  }

  /*
  6th step in supplychain
  Allows distributor to process cheese
  */
  function processedProductByDistributor(uint _upc,uint slices) public
    onlyDistributor() // check msg.sender belongs to DistributorRole
    receivedByDistributor(_upc)
    verifyCaller(products[_upc].ownerID) // check msg.sender is owner
    {
    products[_upc].productState = State.ProcessedByDistributor; // update state
    products[_upc].productSliced = slices; // add slice amount
    emit ProcessedByDistributor(_upc);
  }

  /*
  7th step in supplychain
  Allows distributor to package cheese
  */
  function packageProductByDistributor(uint _upc) public
    onlyDistributor() // check msg.sender belongs to DistributorRole
    processByDistributor(_upc)
    verifyCaller(products[_upc].ownerID) // check msg.sender is owner
    {
    products[_upc].productState = State.PackageByDistributor;
    emit PackagedByDistributor(_upc);
  }

  /*
  8th step in supplychain
  Allows distributor to sell cheese
  */
  function sellProductByDistributor(uint _upc, uint _price) public
    onlyDistributor() // check msg.sender belongs to DistributorRole
    packagedByDistributor(_upc)
    verifyCaller(products[_upc].ownerID) // check msg.sender is owner
    {
        products[_upc].productState = State.ForSaleByDistributor;
        products[_upc].productPrice = _price;
        emit ForSaleByDistributor(_upc);
  }

  /*
  9th step in supplychain
  Allows reseller to purchase cheese
  */
  function purchaseProductByReseller(uint _upc) public payable
    onlyReseller() // check msg.sender belongs to ResellerRole
    forSaleByDistributor(_upc)
    paidEnough(products[_upc].productPrice)
    checkValue(_upc, payable(msg.sender))
    {
    address payable ownerAddressPayable = _make_payable(products[_upc].distributorID);
    ownerAddressPayable.transfer(products[_upc].productPrice);
    products[_upc].ownerID = msg.sender;
    products[_upc].resellerID = payable(msg.sender);
    products[_upc].productState = State.PurchasedByReseller;
    //history[_upc].DTR = block.number;
    emit PurchasedByReseller(_upc);
  }

  /*
  10th step in supplychain
  Allows Distributor to
  */
  function shippedProductByDistributor(uint _upc) public
    onlyDistributor() // check msg.sender belongs to DistributorRole
    purchasedByReseller(_upc)
    verifyCaller(products[_upc].distributorID) // check msg.sender is distributorID
    {
      products[_upc].productState = State.ShippedByDistributor;
      emit ShippedByDistributor(_upc);
  }

  /*
  11th step in supplychain
  */
  function receivedProductByReseller(uint _upc) public
    onlyReseller() // check msg.sender belongs to ResellerRole
    shippedByDistributor(_upc)
    verifyCaller(products[_upc].ownerID) // check msg.sender is ownerID
    {
      products[_upc].productState = State.ReceivedByReseller;
      emit ReceivedByReseller(_upc);
  }

  /*
  12th step in supplychain
  */
  function sellProductByReseller(uint _upc, uint _price) public
    onlyReseller()  // check msg.sender belongs to ResellerRole
    receivedByReseller(_upc)
    verifyCaller(products[_upc].ownerID) // check msg.sender is ownerID
    {
      products[_upc].productState = State.ForSaleByReseller;
      products[_upc].productPrice = _price;
      emit ForSaleByReseller(_upc);
  }

  /*
  13th step in supplychain
  */
  function purchaseProductByEndUser(uint _upc) public payable
    onlyEndUser()  // check msg.sender belongs to EndUserRole
    forSaleByReseller(_upc)
    paidEnough(products[_upc].productPrice)
    checkValue(_upc, payable(msg.sender))
    {
      address payable ownerAddressPayable = _make_payable(products[_upc].resellerID);
      ownerAddressPayable.transfer(products[_upc].productPrice);
      products[_upc].ownerID = msg.sender;
      products[_upc].enduserID = payable(msg.sender);
      products[_upc].productState = State.PurchasedByEndUser;
      //history[_upc].RTC = block.number;
    emit PurchasedByEndUser(_upc);
  }

  // Define a function 'fetchProductBufferOne' that fetches the data
  function fetchProductBufferOne(uint _upc) public view returns
    (
    uint    itemSKU,
    uint    itemUPC,
    address ownerID,
    address originManufacturerID,
    string memory  originName,
    string memory originInformation,
    string memory originLatitude,
    string memory originLongitude,
    uint manufacturedDate,
    uint productSliced
    )
    {
    // Assign values to the 8 parameters
    Product memory item = products[_upc];

    return
    (
      item.sku,
      item.upc,
      item.ownerID,
      item.originID,
      item.originName,
      item.originInformation,
      item.originLatitude,
      item.originLongitude,
      item.manufacturedDate,
      item.productSliced
    );
  }

  // Define a function 'fetchProductBufferTwo' that fetches the data
  function fetchProductBufferTwo(uint _upc) public view returns
    (
    uint    itemSKU,
    uint    itemUPC,
    uint    productID,
    string  memory productNotes,
    uint    productPrice,
    uint256 manufacturedDate,
    State   itemState,
    address distributorID,
    address resellerID,
    address enduserID
    )
    {
      // Assign values to the 9 parameters
    Product memory item = products[_upc];

    return
    (
      item.sku,
      item.upc,
      item.productID,
      item.productNotes,
      item.productPrice,
      item.manufacturedDate,
      item.productState,
      item.distributorID,
      item.resellerID,
      item.enduserID
    );

  }

  // Define a function 'fetchProductHistory' that fetaches the data
  function fetchitemHistory(uint _upc) public view returns
    (
        uint blocksupplierToManufacturer,
        uint blockmanufacturerToDistributor,
        uint blockDistributorToReseller,
        uint blockResellerToEndUser
    )
    {
      // Assign value to the parameters
      //Txblocks memory txblock = history[_upc];
      //return
      //(
      //  txblock.STM,
      //  txblock.MTD,
      //  txblock.DTR,
      //  txblock.RTC
      //);

    }

}